{"version":3,"file":"training-session-impl.js","sources":["../../../../../../../../node_modules/.pnpm/onnxruntime-common@1.20.1/node_modules/onnxruntime-common/dist/esm/training-session-impl.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { resolveBackendAndExecutionProviders } from './backend-impl.js';\nimport { Tensor } from './tensor.js';\nconst noBackendErrMsg = 'Training backend could not be resolved. ' + \"Make sure you're using the correct configuration & WebAssembly files.\";\nexport class TrainingSession {\n    constructor(handler, hasOptimizerModel, hasEvalModel) {\n        this.handler = handler;\n        this.hasOptimizerModel = hasOptimizerModel;\n        this.hasEvalModel = hasEvalModel;\n    }\n    get trainingInputNames() {\n        return this.handler.inputNames;\n    }\n    get trainingOutputNames() {\n        return this.handler.outputNames;\n    }\n    get evalInputNames() {\n        if (this.hasEvalModel) {\n            return this.handler.evalInputNames;\n        }\n        else {\n            throw new Error('This training session has no evalModel loaded.');\n        }\n    }\n    get evalOutputNames() {\n        if (this.hasEvalModel) {\n            return this.handler.evalOutputNames;\n        }\n        else {\n            throw new Error('This training session has no evalModel loaded.');\n        }\n    }\n    static async create(trainingOptions, sessionOptions) {\n        const evalModel = trainingOptions.evalModel || '';\n        const optimizerModel = trainingOptions.optimizerModel || '';\n        const options = sessionOptions || {};\n        // resolve backend, update session options with validated EPs, and create session handler\n        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);\n        if (backend.createTrainingSessionHandler) {\n            const handler = await backend.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);\n            return new TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);\n        }\n        else {\n            throw new Error(noBackendErrMsg);\n        }\n    }\n    /**\n     * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from\n     * the given parameters to SessionHandler.FetchesType and RunOptions.\n     *\n     * @param inputNames the feeds object is checked that they contain all input names in the provided list of input\n     * names.\n     * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output\n     * names.\n     * @param feeds the required input\n     * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object\n     * @param arg2 optional RunOptions object.\n     * @returns\n     */\n    typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n            throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === 'object') {\n            if (arg1 === null) {\n                throw new TypeError('Unexpected argument[1]: cannot be null.');\n            }\n            if (arg1 instanceof Tensor) {\n                throw new TypeError(\"'fetches' cannot be a Tensor\");\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError(\"'fetches' cannot be an empty array.\");\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1) {\n                    if (typeof name !== 'string') {\n                        throw new TypeError(\"'fetches' must be a string array or an object.\");\n                    }\n                    if (outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === 'object' && arg2 !== null) {\n                    options = arg2;\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError(\"'options' must be an object.\");\n                }\n            }\n            else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of outputNames) {\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === 'object' && arg2 !== null) {\n                        options = arg2;\n                    }\n                    else if (typeof arg2 !== 'undefined') {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                }\n                else {\n                    options = arg1;\n                }\n            }\n        }\n        else if (typeof arg1 !== 'undefined') {\n            throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        }\n        // check if all inputs are in feed\n        for (const name of inputNames) {\n            if (typeof feeds[name] === 'undefined') {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of outputNames) {\n                fetches[name] = null;\n            }\n        }\n        return [fetches, options];\n    }\n    /**\n     * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler\n     * and changes it into a map of Tensors.\n     *\n     * @param results\n     * @returns\n     */\n    convertHandlerReturnTypeToMapOfTensors(results) {\n        const returnValue = {};\n        for (const key in results) {\n            if (Object.hasOwnProperty.call(results, key)) {\n                const result = results[key];\n                if (result instanceof Tensor) {\n                    returnValue[key] = result;\n                }\n                else {\n                    returnValue[key] = new Tensor(result.type, result.data, result.dims);\n                }\n            }\n        }\n        return returnValue;\n    }\n    async lazyResetGrad() {\n        await this.handler.lazyResetGrad();\n    }\n    async runTrainStep(feeds, arg1, arg2) {\n        const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);\n        const results = await this.handler.runTrainStep(feeds, fetches, options);\n        return this.convertHandlerReturnTypeToMapOfTensors(results);\n    }\n    async runOptimizerStep(options) {\n        if (this.hasOptimizerModel) {\n            await this.handler.runOptimizerStep(options || {});\n        }\n        else {\n            throw new Error('This TrainingSession has no OptimizerModel loaded.');\n        }\n    }\n    async runEvalStep(feeds, arg1, arg2) {\n        if (this.hasEvalModel) {\n            const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);\n            const results = await this.handler.runEvalStep(feeds, fetches, options);\n            return this.convertHandlerReturnTypeToMapOfTensors(results);\n        }\n        else {\n            throw new Error('This TrainingSession has no EvalModel loaded.');\n        }\n    }\n    async getParametersSize(trainableOnly = true) {\n        return this.handler.getParametersSize(trainableOnly);\n    }\n    async loadParametersBuffer(array, trainableOnly = true) {\n        const paramsSize = await this.getParametersSize(trainableOnly);\n        // checking that the size of the Uint8Array is equivalent to the byte length of a Float32Array of the number\n        // of parameters\n        if (array.length !== 4 * paramsSize) {\n            throw new Error('Size of the buffer passed into loadParametersBuffer must match the number of parameters in ' +\n                'the model. Please use getParametersSize method to check.');\n        }\n        return this.handler.loadParametersBuffer(array, trainableOnly);\n    }\n    async getContiguousParameters(trainableOnly = true) {\n        return this.handler.getContiguousParameters(trainableOnly);\n    }\n    async release() {\n        return this.handler.dispose();\n    }\n}\n//# sourceMappingURL=training-session-impl.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}